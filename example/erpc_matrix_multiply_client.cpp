/*
 * You can write copyrights rules here. These rules will be copied into the outputs.
 */

/*
 * Generated by erpcgen 1.9.1 on Thu Dec  8 03:00:50 2022.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "client.h"
#include "erpc_port.h"
#include <err.h>
#include "erpc_codec.hpp"
extern "C"
{
#include "erpc_matrix_multiply.h"
}

#if 10901 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;



// Constant variable definitions
#pragma weak matrix_size
extern const int32_t matrix_size = 2;


// MatrixMultiplyService interface erpcMatrixMultiply function client shim.
void MatrixMultiplyServiceClient::erpcMatrixMultiply(Matrix matrix1, Matrix matrix2, Matrix result_matrix)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kMatrixMultiplyService_service_id, kMatrixMultiplyService_erpcMatrixMultiply_id, request.getSequence());

        for (uint32_t arrayCount0 = 0U; arrayCount0 < 2U; ++arrayCount0)
        {
            for (uint32_t arrayCount1 = 0U; arrayCount1 < 2U; ++arrayCount1)
            {
                codec->write(matrix1[arrayCount0][arrayCount1]);
            }
        }

        for (uint32_t arrayCount0 = 0U; arrayCount0 < 2U; ++arrayCount0)
        {
            for (uint32_t arrayCount1 = 0U; arrayCount1 < 2U; ++arrayCount1)
            {
                codec->write(matrix2[arrayCount0][arrayCount1]);
            }
        }

        // Send message to server
        // Codec status is checked inside this function.
        performRequest(request);

        for (uint32_t arrayCount0 = 0U; arrayCount0 < 2U; ++arrayCount0)
        {
            for (uint32_t arrayCount1 = 0U; arrayCount1 < 2U; ++arrayCount1)
            {
                codec->read(&result_matrix[arrayCount0][arrayCount1]);
            }
        }

        err = codec->getStatus();
    }

    // Dispose of the request.
    releaseRequest(request);

    // Invoke error handler callback function
    callErrorHandler(err, kMatrixMultiplyService_erpcMatrixMultiply_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}

// MatrixMultiplyService interface erpctest function client shim.
void MatrixMultiplyServiceClient::erpctest(int32_t num1, int32_t num2, int32_t * ret)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kMatrixMultiplyService_service_id, kMatrixMultiplyService_erpctest_id, request.getSequence());

        codec->write(num1);

        codec->write(num2);

        // Send message to server
        // Codec status is checked inside this function.
        performRequest(request);

        codec->read(ret);

        err = codec->getStatus();
    }

    // Dispose of the request.
    releaseRequest(request);

    // Invoke error handler callback function
    callErrorHandler(err, kMatrixMultiplyService_erpctest_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}
